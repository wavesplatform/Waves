package scorex.transaction

import java.util.concurrent.locks.ReentrantReadWriteLock

import com.wavesplatform.state2._
import scorex.block.Block.BlockId
import scorex.block.{Block, MicroBlock}
import scorex.transaction.History.BlockchainScore
import scorex.transaction.ValidationError.GenericError

trait NgHistoryWriter extends HistoryWriter {
  def appendMicroBlock(microBlock: MicroBlock): Either[ValidationError, Unit]

  def bestLiquidBlock(): Option[Block]
}

class NgHistoryWriterImpl(inner: HistoryWriter) extends NgHistoryWriter {

  override def synchronizationToken: ReentrantReadWriteLock = inner.synchronizationToken

  private val baseBlock = Synchronized(Option.empty[Block])
  private val micros = Synchronized(List.empty[MicroBlock])

  def bestLiquidBlock(): Option[Block] = write { implicit l =>
    baseBlock().map(base => {
      val ms = micros()
      if (ms.isEmpty) {
        base
      } else {
        base.copy(
          signerData = base.signerData.copy(signature = ms.head.totalResBlockSig),
          transactionData = base.transactionData ++ ms.map(_.transactionData).reverse.flatten)
      }
    })
  }

  override def appendBlock(block: Block): Either[ValidationError, Unit] = write { implicit l =>
    if (inner.height() == 0 || inner.lastBlock.uniqueId == block.reference) {
      micros.set(List.empty)
      baseBlock.set(Some(block))
      Right(())
    } else forgeBlock(block.reference) match {
      case Some(forgedBlock) =>
        inner.appendBlock(forgedBlock).explicitGet()
        micros.set(List.empty)
        baseBlock.set(Some(block))
        Right(())
      case None =>
        Left(GenericError(s"Failed to append block ${block.encodedId} because its parent(${block.reference.base58} " +
          s"is neither last one in persisted blockchain nor liquid"))
    }
  }

  override def discardBlock(): Unit = write { implicit l =>
    if (baseBlock().isDefined) {
      baseBlock.set(None)
      micros.set(List.empty)
    } else {
      inner.discardBlock()
    }
  }

  override def height(): Int = read { implicit l =>
    inner.height() + baseBlock().map(_ => 1).getOrElse(0)
  }

  override def blockBytes(height: Int): Option[Array[Byte]] = read { implicit l =>
    inner.blockBytes(height).orElse(if (height == inner.height() + 1) bestLiquidBlock().map(_.bytes) else None)
  }

  override def scoreOf(blockId: BlockId): Option[BlockchainScore] = read { implicit l =>
    inner.scoreOf(blockId)
      .orElse(if (containsLocalBlock(blockId))
        Some(inner.score() + baseBlock().get.blockScore)
      else None)
  }

  override def heightOf(blockId: BlockId): Option[Int] = read { implicit l =>
    lazy val innerHeight = inner.height()
    inner.heightOf(blockId).orElse(if (containsLocalBlock(blockId))
      Some(innerHeight + 1)
    else
      None)
  }

  override def lastBlockIds(howMany: Int): Seq[BlockId] = read { implicit l =>
    baseBlock() match {
      case Some(base) =>
        micros().headOption.map(_.totalResBlockSig).getOrElse(base.uniqueId) +: inner.lastBlockIds(howMany - 1)
      case None =>
        inner.lastBlockIds(howMany)
    }
  }

  override def appendMicroBlock(microBlock: MicroBlock): Either[ValidationError, Unit] = write { implicit l =>
    baseBlock() match {
      case Some(base) if base.signerData.generator == microBlock.generator =>
        micros().headOption match {
          case None =>
            if (base.uniqueId == microBlock.prevResBlockSig) {
              micros.set(microBlock +: micros())
              Right(())
            }
            else {
              Left(GenericError(s"MicroBlock $microBlock can't be appended because it is first micro and it doesn't reference existing base block"))
            }
          case Some(prevMicro) =>
            if (prevMicro.totalResBlockSig == microBlock.prevResBlockSig) {
              micros.set(microBlock +: micros())
              Right(())
            } else {
              Left(GenericError(s"Microblock $microBlock can't be appended because it doesn't reference last known microBlock"))
            }
        }
      case Some(_) =>
        Left(GenericError(s"MicroBlock $microBlock can't be appended because base block has been generated by another account"))
      case None =>
        Left(GenericError(s"MicroBlock $microBlock can't be appended because no base block exists"))
    }
  }

  private def containsLocalBlock(blockId: BlockId): Boolean = read { implicit l =>
    baseBlock().find(_.uniqueId == blockId)
      .orElse(micros().find(_.totalResBlockSig == blockId)).isDefined
  }

  private def forgeBlock(id: BlockId): Option[Block] = read { implicit l =>
    baseBlock().flatMap(base => {
      lazy val ms = micros()
      if (base.uniqueId == id) {
        Some(base)
      } else {
        val (txs, found) = ms.reverse.foldLeft((List.empty[Transaction], false)) { case ((accumulated, matched), micro) =>
          if (matched)
            (accumulated, matched)
          else
            (accumulated ++ micro.transactionData, false)
        }
        if (found)
          Some(base.copy(
            signerData = base.signerData.copy(signature = ms.head.totalResBlockSig),
            transactionData = base.transactionData ++ txs))
        else None
      }
    })
  }
}
